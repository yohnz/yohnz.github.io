{"meta":{"title":"酱油铺","subtitle":null,"description":"这是一个酱油铺","author":"打酱油的小前端","url":"http://yohnz.github.io"},"pages":[{"title":"Tags","date":"2016-10-02T04:58:06.098Z","updated":"2016-08-24T03:19:16.818Z","comments":true,"path":"tags/index.html","permalink":"http://yohnz.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-10-02T04:58:23.090Z","updated":"2016-08-24T03:19:16.817Z","comments":true,"path":"categories/index.html","permalink":"http://yohnz.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2016-08-29T06:34:26.335Z","updated":"2016-08-29T06:34:26.335Z","comments":true,"path":"about/index.html","permalink":"http://yohnz.github.io/about/index.html","excerpt":"","text":"一个打酱油的小前端，喜欢折腾前端。"}],"posts":[{"title":"手把手教你把前端代码打包成msi和exe应用","slug":"手把手教你把前端代码打包成msi和exe应用/手把手教你把前端代码打包成msi和exe应用","date":"2016-10-11T09:42:54.000Z","updated":"2016-10-12T09:34:33.370Z","comments":true,"path":"2016/10/11/手把手教你把前端代码打包成msi和exe应用/手把手教你把前端代码打包成msi和exe应用/","link":"","permalink":"http://yohnz.github.io/2016/10/11/手把手教你把前端代码打包成msi和exe应用/手把手教你把前端代码打包成msi和exe应用/","excerpt":"本文主要介绍Electron应用如何打包成msi和exe文件。由于介绍Electron打包成msi和exe的文章很少，官方的文档也一笔带过，在研究的过程中踩了很多坑，所以写下此文，给其他人一个参考。关于Electron基础知识的文章，官方文档很详细，在此不再赘述，还没入门的童鞋可以看看方的入门文档:https://github.com/electron/electron/blob/master/docs-translations/zh-CN/tutorial/quick-start.md","text":"本文主要介绍Electron应用如何打包成msi和exe文件。由于介绍Electron打包成msi和exe的文章很少，官方的文档也一笔带过，在研究的过程中踩了很多坑，所以写下此文，给其他人一个参考。关于Electron基础知识的文章，官方文档很详细，在此不再赘述，还没入门的童鞋可以看看方的入门文档:https://github.com/electron/electron/blob/master/docs-translations/zh-CN/tutorial/quick-start.md 照着本文操作前，请确保电脑上已经安装了NodeJs,Electron模块,然后有一个写好的Electron应用。 打包成运行包没打包之前，想要用Electron运行你的应用有两种方式 在应用目录打开命令行，输入electron . 在命令行输入electron,启动一个Electron窗口，并把mian.js拖入窗口中。 这种方式不太优雅，我想直接双击就能运行呢？那就要用到常规打包(以下步骤都是在应用根目录,即上图的Electron_Zhihu下)： 1. 安装依赖常规打包需要用到electron-packager模块，所以先在命令行中输入npm install --save-dev electron-packager安装。2. package.json里添加一条打包命令，免得每次打包都要输入一长串命令123\"scripts\": &#123; \"package\": \"electron-packager ./ zhihu --win --out zhihu --arch=x64 --version 1.3.4 --overwrite --ignore=node_modules\" &#125; 参数说明electron-packager &lt;location of project&gt; &lt;name of project&gt; &lt;platform&gt; &lt;architecture&gt; &lt;electron version&gt; &lt;optional options&gt;location of project：应用目录;name of project：应用名称;platform：要打包的平台;architecture：x86 or x64架构;electron version：electron 版本(不是应用版本);optional options：其它选项; 3. 执行npm run-script package开始打包,第一次打包会下载相应平台的包,可能会比较久打包完毕后，会多出来一个目录,比如我的是zhihu,打开之后，会有一个zhihu-win32-x64目录，里面就是打包生成的各种文件:zhihu.exe是可以直接双击运行的，resources里是源文件。注意,node_modules不会被打包进去，如果有依赖，记得进入resources/app目录输入npm install安装一下依赖。 打包成安装包为什么要打包成安装包呢，因为安装包更像原生桌面端应用，更重要的是，安装官方文档，如果想要应用自动更新，必须先打包成安装包。 Electron官方推荐使用grunt-electron-installer模块自动生成 Windows 安装向导。注意：以下操作都在zhihu-win32-x64的父级目录中1. 安装grunt-electron-installer新建package.json文件package.json的内容可以简单写下:1234&#123; \"name\": \"zhihu\", \"version\": \"1.0.0\" &#125; 打开命令行，输入npm install grunt-electron-installer --save-dev安装grunt-electron-installer模块,接着输入npm install grunt --save-dev安装grunt。 2. 配置Gruntfile.js因为要用到grunt执行打包任务，所以，新建一个Gruntfile.js文件，并配置gurnt.config,我的配置如下：123456789101112131415var grunt = require(\"grunt\");grunt.config.init(&#123; pkg: grunt.file.readJSON('package.json'), 'create-windows-installer': &#123; x64: &#123; appDirectory: './zhihu-win32-x64', authors: 'yohnz.', exe: 'zhihu.exe', description:\"zhihu\", &#125; &#125;&#125;)grunt.loadNpmTasks('grunt-electron-installer');grunt.registerTask('default', ['create-windows-installer']); 配置说明： Config Name Required Description appDirectory Yes Electron App 的目录 outputDirectory No 输出exe的目录. 默认生成在installer目录. loadingGif No 安装过程中的加载动画图片. authors Yes 作者,若未指明，则从应用的package.json文件中读取 owners No 应用拥有者，若未定义则与作者相同. exe No 应用的入口exe名称. description No 应用描述 version No 应用版本号. title No 应用的标题. certificateFile No 证书文件 certificatePassword No 加密密钥 signWithParams No 传递给signtool签名工具的参数，如果软件不签名，可以忽略这个 iconUrl No 应用图标链接，默认是Atom的图标. setupIcon No Setup.exe 的icon noMsi No 是否创建.msi安装文件? remoteReleases No 更新链接，如果填写，当链接中有新版本，会自动下载安装。 3. grunt打包在命令行输入npm grunt,就会执行自动构建安装程序。在构建完之后的installer目录(或者你配置的输出目录)中会有如下几个文件 参考资料：https://github.com/electron/grunt-electron-installerhttps://github.com/electron/electron/blob/master/docs-translations/zh-CN/api/auto-updater.mdhttp://blog.csdn.net/w342916053/article/details/51701722","categories":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"http://yohnz.github.io/tags/Electron/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}]},{"title":"nodeJs小知识","slug":"nodeJs小知识","date":"2016-09-09T09:50:23.000Z","updated":"2016-09-13T03:39:02.264Z","comments":true,"path":"2016/09/09/nodeJs小知识/","link":"","permalink":"http://yohnz.github.io/2016/09/09/nodeJs小知识/","excerpt":"","text":"nodeJs直接调用grunt任务nodeJs里直接调用grunt任务其实很简单，直接用grunt.cli来运行：1var grunt = require(&#39;grunt&#39;);&#10;var path = require(&#39;path&#39;);&#10;grunt.cli(&#123;&#10; gruntfile: __path + &#39;/Gruntfile.js&#39;&#10;&#125;) 还可以直接设置默认任务：1grunt.registerTask(\"default\", [`project-watch:$&#123;project_config.projectName&#125;`]); nodeJs获取上层目录 123const path = require('path');var grunt = require(\"grunt\");var __path = path.resolve(__dirname, '..') 待续…","categories":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}],"tags":[{"name":"nodeJs","slug":"nodeJs","permalink":"http://yohnz.github.io/tags/nodeJs/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}]},{"title":"Electron折腾笔记","slug":"Electron折腾笔记","date":"2016-09-09T07:30:32.000Z","updated":"2016-09-13T03:34:49.267Z","comments":true,"path":"2016/09/09/Electron折腾笔记/","link":"","permalink":"http://yohnz.github.io/2016/09/09/Electron折腾笔记/","excerpt":"Electron折腾笔记 背景部门的项目每次开发都需要手动开启三个服务：server、webpack、grunt，每个服务都要输入一些东西（端口号，项目命，项目类型，启动器名）。而且，在推送调试的时候，这三项服务非常容易被终止掉，然后又得一个个开起来，总之每天都要来上那么10几遍吧。看图：","text":"Electron折腾笔记 背景部门的项目每次开发都需要手动开启三个服务：server、webpack、grunt，每个服务都要输入一些东西（端口号，项目命，项目类型，启动器名）。而且，在推送调试的时候，这三项服务非常容易被终止掉，然后又得一个个开起来，总之每天都要来上那么10几遍吧。看图： 思考如果可以一键启动三个服务，又可以免去手动输入参数岂不又多了点偷懒的时间？ 功能 一键启动、关闭项目开发过程中需要开启的三项服务 自动解析出服务运行所需的三个不同目录，免去一个个手动输入的麻烦 可以保存配置，下次免配置 开工因为想做成小软件的形式，所以选用了Electron。以下是一些主要的思路和功能代码记录。 工具窗口 工具窗口部分，基本上用官网guide里的代码就足够了1234567891011121314151617181920212223242526const electron = require(\"electron\");const &#123;app, BrowserWindow, shell, ipcMain&#125; = electron;let win;function createWdindow() &#123; win = new BrowserWindow(&#123; width: 400, height: 680,resizable:true,title: 'prensterTool',&#125;) win.loadURL(`file://$&#123;__dirname&#125;/index.html`) win.on(\"close\", () =&gt; &#123; win = null; &#125;);&#125;app.on(\"ready\", createWdindow);// 当全部窗口关闭时退出app.on('window-all-closed', () =&gt; &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== 'darwin') &#123; app.quit(); &#125;&#125;);app.on('activate', () =&gt; &#123; // 在 macOS 上，当点击 dock 图标并且该应用没有打开的窗口时， // 绝大部分应用会重新创建一个窗口。 if (mainWindow === null) &#123; createWindow(); &#125;&#125;); 自定义菜单12345678910111213141516const remote = require('electron').remote;const Menu = remote.Menu;const MenuItem = remote.MenuItem;var template = [ &#123; label: '配置', submenu: [ &#123; label: '重新配置', accelerator: 'CmdOrCtrl+shift+alt+r', click: function () &#123; reset(); &#125; &#125;, &#123; label: '保存配置', accelerator: 'CmdOrCtrl+shift+alt+s', click: function () &#123; saveSetting(); &#125; &#125; ] &#125; // ……];var menu = Menu.buildFromTemplate(template);Menu.setApplicationMenu(menu); 保存配置信息 在工作目录拖拽小工具上时，读取文件目录，本写入配置文件，供后面的功能使用。 读取文件路径：123var file = e.dataTransfer.files[0];presenterPath = file.path;showInfo(presenterPath); 写入配置文件123456var data = `module.exports =` &#123;projectName:\"$&#123;projectName&#125;\",presenterId:\"$&#123;presenterId&#125;\"&#125;`; fs.writeFile(\"./resources/app/project_config.js\", data, function (err) &#123; if (err) &#123; showInfo(err.toString()); return; &#125; 调用服务调用服务部分，主要用到nodejs的子进程exec。1234567891011121314functon startServices()&#123;// webpack var processWebpack = childProcess.exec('webpack --watch', &#123; 'cwd': `$&#123;__path&#125;/presenters/SubjectToolSolution/$&#123;presenterId&#125;/src` &#125;);showLog('Webpack', processWebpack);pids.push(processWebpack.pid);// servervar processServices = childProcess.exec('node services', &#123; 'cwd': __path &#125;);showLog('Server', processServices);pids.push(processServices.pid);// gruntvar processGrunt = childProcess.exec('node gruntTask', &#123; 'cwd': __dirname &#125;);showLog('Grunt', processGrunt);pids.push(processGrunt.pid);&#125; 踩坑 Electron关闭的时候不会关闭node的子进程，所以，要手动关闭。开始做的时候，服务总是偶尔开启成功，后面就不行了，很是诡异，查了一下午都无果，直到我无意中开了任务管理器，看到那一堆的node服务… 思路：开启服务的时候把子进程的pid存起来，待后面kill. 123456789101112131415161718192021var platform = process.platform;function killTask() &#123; try &#123; if (platform === 'win32') &#123; for (let pid of pids) &#123; childProcess.exec('taskkill /pid ' + pid + ' /T /F'); &#125; pids = []; &#125; else &#123; for (let pid of pids) &#123; process.kill(processServices.pid); &#125; pids = []; &#125; &#125; catch (e) &#123; showInfo('pid not found'); &#125; domLog.innerHTML = \"\"; showInfo(\"服务已停止!\"); clearInterval(timerId);&#125; Electron打包完之后，代码里的path变了，要手动处理下，不知道是不是姿势不对？ ELectron打包关于打包的问题，官网的文档看的我真是一脸懵逼，知乎专栏的这篇文章不错，可以参考下https://zhuanlan.zhihu.com/p/20225295 步骤 安装electron-packager：npm install --save-dev electron-packager package.json里添加打包命令： 1234\"scripts\": &#123;\"start\": \"electron .\",\"package\": \"electron-packager ./ app --win --out presenterTool --arch=x64 --version 1.3.4 --overwrite --ignore=node_modules\" &#125; 执行npm run-script package开始打包 参数说明 electron-packager &lt;location of project&gt; &lt;name of project&gt; &lt;platform&gt; &lt;architecture&gt; &lt;electron version&gt; &lt;optional options&gt; location of project：应用目录; name of project：应用名称; platform：要打包的平台; architecture：x86 or x64架构; electron version：electron 版本(不是应用版本); optional options：其它选项; 第一次打包会下载相应的包，时间比较久 记得打包参数里写上overwrite，不然后面打包时不会重新构建。 最后，上一张初步完成之后的运行图：","categories":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"http://yohnz.github.io/tags/Electron/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}]},{"title":"极简天气","slug":"自己动手写chrome天气扩展","date":"2016-05-17T00:58:54.000Z","updated":"2016-09-09T09:43:29.939Z","comments":true,"path":"2016/05/17/自己动手写chrome天气扩展/","link":"","permalink":"http://yohnz.github.io/2016/05/17/自己动手写chrome天气扩展/","excerpt":"先上效果图： 下面我们一步步来~","text":"先上效果图： 下面我们一步步来~ 创建文件新建weather文件夹，里面包含manifest.json，popup.html和images文件夹。images文件夹放16,48,128三种不同尺寸的图标 manifest.json内代码如下：1234567891011121314151617&#123; \"manifest_version\":2, \"name\":\"极简天气\", \"description\":\"极简天气预报\", \"version\":\"1.0\", \"icons\": &#123; \"16\": \"images/sun16.png\", \"48\": \"images/sun48.png\", \"128\": \"images/sun128.png\" &#125;, \"browser_action\":&#123; \"default_icon\":\"images/sun48.png\", \"default_title\":\"天气预报\", \"default_popup\":\"popup.html\" &#125;, &#125; popup.html的代码如下：123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;天气&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"weather\"&gt; Test &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 文件说明manifest.json 必需文件，是整个扩展的入口，每个Chrome扩展都包含一个Manifest文件。Manifest必须包含name、version和manifest_version属性。 属性说明： manifest_version指定文件格式的版本，在Chrome18之后，应该都是2 name扩展名称 version 扩展版本号 version扩展的版本 icons扩展列表图标 browser_action指定扩展在Chrome工具栏中的显示信息。 default_icon、default_title、default_popup依次指定图标、标题、对应的页面 Popup页面 Popup页面是当用户点击扩展图标时，展示在图标下面的页面。 打开chrome扩展程序界面，勾选”开发者模式”,拖入weather文件夹，然后就可以看到weather扩展已经出现在chrome扩展程序列表了 同时，工具栏也出现了weather的图标，点击之后会弹出popup界面: 完善页面和样式完善静态popup页面,模拟天气数据:12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;天气&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"weather\"&gt; &lt;div class=\"today\" id=\"today\"&gt; &lt;h1 class=\"city\"&gt;厦门&lt;/h1&gt; &lt;div class=\"row_detail\"&gt;![](http://upload-images.jianshu.io/upload_images/1281368-9e0ad1352ce6bb91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) &lt;h1&gt;19&lt;span&gt;℃&lt;/span&gt;&lt;/h1&gt;&lt;/div&gt; &lt;div class=\"wind\"&gt; &lt;h2&gt;阴&lt;/h2&gt; &lt;h4&gt;风速 20 湿度 89%&lt;/h4&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;div class=\"row\"&gt; &lt;h4&gt;2016-05-16&lt;/h4&gt;![](http://upload-images.jianshu.io/upload_images/1281368-9e0ad1352ce6bb91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) &lt;h1&gt;19~24&lt;/h1&gt; &lt;h4&gt;阴&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 新建CSS文件，并在popup页面引入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758body&#123; width:740px; height:400px; font-family: 'Microsoft Yahei'; color:#333; background:#fefefe; text-shadow:1px 1px 6px #333;&#125;.city&#123; text-align:center&#125;.today&#123; padding-bottom:30px;&#125;.row_detail&#123; display: flex; direction: row; justify-content:center; align-items: center;&#125;.row_detail img&#123; width:80px; &#125;.row_detail h1&#123; font-size:60px;&#125;.wind&#123; text-align: center;&#125;.content&#123; display: flex; direction: column&#125;.wrap&#123; display: flex; direction: row; flex: 1; justify-content:space-around; align-items: center;&#125;.row&#123; background:#fff; border:1px solid #ccc; padding:10px; box-shadow: 0 2px 10px rgba(0,0,0,.3);&#125;.row img&#123; width:80px;&#125;.row h1&#123; font-size:18px;&#125;h1,h4&#123; text-align: center; margin:0;&#125; 点击工具栏weather图标，此时界面如图： 获取真实天气数据Google允许Chrome扩展应用不必受限于跨域限制。但出于安全考虑，需要在Manifest的permissions属性中声明需要跨域的权限。这里以和风天气API为例.首先，在Manifest里添加要请求的API接口：123\"permissions\":[ \"http://api.openweathermap.org/data/2.5/forecast?q=*\", ] 然后新建popup.js并在popup页面中引入简单的ajax函数：12345678910function httpRequest(url,callback) &#123; var xhr = new XMLHttpRequest(); xhr.open('GET',url,true); xhr.onreadystatechange = function() &#123; if(xhr.readyState === 4)&#123; callback(xhr.responseText); &#125; &#125; xhr.send();&#125; 和风天气API可以通过城市名称，城市代码,IP三种方式来获取指定城市天气数据，不过经过测试发现，IP获取的方式不准确，城市有偏差，所以，直接用城市名称来获取。这里借用http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json获取城市名称。1234567891011httpRequest('http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json',function(data) &#123; if(!data) return; data = JSON.parse(data); var city = data.city; var url = 'https://api.heweather.com/x3/weather?city='+city+'&amp;key=youkey'; httpRequest(url,function(data) &#123; data = JSON.parse(data); var result = data[\"HeWeather data service 3.0\"][0]; showWeather(city,result); &#125;);&#125;); 为了方便的解析图片，构建一个json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var cond_info = &#123;100:\"http://files.heweather.com/cond_icon/100.png\",101:\"http://files.heweather.com/cond_icon/101.png\",102:\"http://files.heweather.com/cond_icon/102.png\",103:\"http://files.heweather.com/cond_icon/103.png\",104:\"http://files.heweather.com/cond_icon/104.png\",200:\"http://files.heweather.com/cond_icon/200.png\",201:\"http://files.heweather.com/cond_icon/201.png\",202:\"http://files.heweather.com/cond_icon/202.png\",203:\"http://files.heweather.com/cond_icon/203.png\",204:\"http://files.heweather.com/cond_icon/204.png\",205:\"http://files.heweather.com/cond_icon/205.png\",206:\"http://files.heweather.com/cond_icon/206.png\",207:\"http://files.heweather.com/cond_icon/207.png\",208:\"http://files.heweather.com/cond_icon/208.png\",209:\"http://files.heweather.com/cond_icon/209.png\",210:\"http://files.heweather.com/cond_icon/210.png\",211:\"http://files.heweather.com/cond_icon/211.png\",212:\"http://files.heweather.com/cond_icon/212.png\",213:\"http://files.heweather.com/cond_icon/213.png\",300:\"http://files.heweather.com/cond_icon/300.png\",301:\"http://files.heweather.com/cond_icon/301.png\",302:\"http://files.heweather.com/cond_icon/302.png\",303:\"http://files.heweather.com/cond_icon/303.png\",304:\"http://files.heweather.com/cond_icon/304.png\",305:\"http://files.heweather.com/cond_icon/305.png\",306:\"http://files.heweather.com/cond_icon/306.png\",307:\"http://files.heweather.com/cond_icon/307.png\",308:\"http://files.heweather.com/cond_icon/308.png\",309:\"http://files.heweather.com/cond_icon/309.png\",310:\"http://files.heweather.com/cond_icon/310.png\",311:\"http://files.heweather.com/cond_icon/311.png\",312:\"http://files.heweather.com/cond_icon/312.png\",313:\"http://files.heweather.com/cond_icon/313.png\",400:\"http://files.heweather.com/cond_icon/400.png\",401:\"http://files.heweather.com/cond_icon/401.png\",402:\"http://files.heweather.com/cond_icon/402.png\",403:\"http://files.heweather.com/cond_icon/403.png\",404:\"http://files.heweather.com/cond_icon/404.png\",405:\"http://files.heweather.com/cond_icon/405.png\",406:\"http://files.heweather.com/cond_icon/406.png\",407:\"http://files.heweather.com/cond_icon/407.png\",500:\"http://files.heweather.com/cond_icon/500.png\",501:\"http://files.heweather.com/cond_icon/501.png\",502:\"http://files.heweather.com/cond_icon/502.png\",503:\"http://files.heweather.com/cond_icon/503.png\",504:\"http://files.heweather.com/cond_icon/504.png\",506:\"http://files.heweather.com/cond_icon/506.png\",507:\"http://files.heweather.com/cond_icon/507.png\",508:\"http://files.heweather.com/cond_icon/508.png\",900:\"http://files.heweather.com/cond_icon/900.png\",901:\"http://files.heweather.com/cond_icon/901.png\",999:\"http://files.heweather.com/cond_icon/999.png\"&#125; showWeather()函数构建DOM; 1234567891011121314151617181920212223242526function showWeather(city,result) &#123; var daily = result.daily_forecast; var now = result.now; var dailyDom=''; for(var i=0;i&lt;daily.length;i++)&#123; var day = daily[i]; dailyDom += '&lt;div class=\"row\"&gt;' +'&lt;h4&gt;'+day.date+'&lt;/h4&gt;' +'[站外图片上传中……(3)]' +'&lt;h1&gt;'+day.tmp.min+'~'+day.tmp.max+'&lt;/h1&gt;' +'&lt;h4&gt;'+day.cond.txt_d+'&lt;/h4&gt;' +'&lt;/div&gt;' &#125; var today = '&lt;h1 class=\"city\"&gt;'+city+'&lt;/h1&gt;' +'&lt;div class=\"row_detail\"&gt;' +'[站外图片上传中……(4)]' +'&lt;h1&gt;'+now.tmp+'&lt;span&gt;℃&lt;/span&gt;&lt;/h1&gt;' +'&lt;/div&gt;' +'&lt;div class=\"wind\"&gt;' +'&lt;h2&gt;'+now.cond.txt+'&lt;/h2&gt;' +'&lt;h4&gt;风速 '+now.wind.spd+' 湿度 '+now.hum+'%&lt;/h4&gt;' +'&lt;/div&gt;' document.getElementById('today').innerHTML = today; document.getElementById('wrap').innerHTML = dailyDom; &#125; 这时，再点击weather图标，天气扩展基本上就完成了，不过因为和风API有请求次数限制，也为了减少请求，这里做一下数据缓存。12345678910111213141516171819202122var _time = new Date().getTime()-(60*60*1000*2); //接口次数有限，两小时请求一次var storageTime = localStorage.updateTime||0;httpRequest('http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json',function(data) &#123; if(!data) return; data = JSON.parse(data); var city = data.city; var url = 'https://api.heweather.com/x3/weather?city='+city+'&amp;key=youkey'; if(_time&gt;storageTime)&#123; httpRequest(url,function(data) &#123; data = JSON.parse(data); var result = data[\"HeWeather data service 3.0\"][0]; showWeather(city,result); localStorage.updateTime = new Date().getTime(); localStorage.data = JSON.stringify(result); &#125;); &#125;else&#123; var result = JSON.parse(localStorage.data); showWeather(city,result); &#125;&#125;); 至此，一个简单的chrome天气扩展就完成了，是不是比想象中更简单? github源码 https://github.com/yohnz/weather 如果觉得本文有帮助，请github赏个star~","categories":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}],"tags":[{"name":"chrome扩展","slug":"chrome扩展","permalink":"http://yohnz.github.io/tags/chrome扩展/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}]},{"title":"'react-native踩过的坑'","slug":"react-native踩过的坑","date":"2016-04-15T04:18:37.000Z","updated":"2016-09-09T09:48:03.066Z","comments":true,"path":"2016/04/15/react-native踩过的坑/","link":"","permalink":"http://yohnz.github.io/2016/04/15/react-native踩过的坑/","excerpt":"小米真机运行白屏这是因为调试的应用没有“显示悬浮窗”的权限，需要手动开启，开启方法： 打开‘安全中心’应用，点击‘授权管理’，点击‘应用权限管理’ 在打开的应用列表里找到调试的应用并点击 点击‘显示悬浮窗’，选择‘允许’","text":"小米真机运行白屏这是因为调试的应用没有“显示悬浮窗”的权限，需要手动开启，开启方法： 打开‘安全中心’应用，点击‘授权管理’，点击‘应用权限管理’ 在打开的应用列表里找到调试的应用并点击 点击‘显示悬浮窗’，选择‘允许’ “lodash/find”错误这种错误常见于真机运行时出现，而模拟器正常,如图： google了许久也没发现解决方案，后来无意中发现，问题的原因是由于开启了JS Dev Mode，解决方案：摇晃手机，点击Dev Settings打开调试选项，关掉JS Dev Mode选项:","categories":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yohnz.github.io/tags/react-native/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}]},{"title":"sublime打造美美哒的开发环境","slug":"sublime打造美美哒的开发环境","date":"2016-02-26T03:09:13.000Z","updated":"2016-09-09T09:51:53.888Z","comments":true,"path":"2016/02/26/sublime打造美美哒的开发环境/","link":"","permalink":"http://yohnz.github.io/2016/02/26/sublime打造美美哒的开发环境/","excerpt":"最近折腾了下sublime,同事说很漂亮，就分享一下。先上美图镇楼：","text":"最近折腾了下sublime,同事说很漂亮，就分享一下。先上美图镇楼： 美美哒的sublime Text主题再加上半透明效果，看起来真是赏心悦目有木有.好了，废话少说，先看用到的插件： Material Theme 传送门:[https://github.com/equinusocio/material-theme] SublimeText Transparent 传送门:[https://github.com/vhanla/SublimeTextTrans] Material Theme可以直接在sublimeText install package里安装,装完如果效果不理想，请在Preferences-&gt;Setting User里添加相应配置代码，我的如下：1234567891011&#123; \"color_scheme\": \"Packages/Material Theme/schemes/Material-Theme.tmTheme\", \"font-face\": \"monaco\", \"font_size\": 12, \"ignored_packages\": [ \"Vintage\" ], \"material_theme_accent_orange\": true, \"theme\": \"Material-Theme.sublime-theme\"&#125; SublimeText Transparent 貌似需要git clone下来,然后Preferences-&gt;Brower Packages...打开Packages目录,拷贝进去sublimeText就半透明了。 这样配置不仅比较好看，而且配合live load，可以把网页或者模拟器之类的直接放在IDE下面，实时调试，头都不用扭啊。尤其是在那种一台显示器显示着设计稿，文档，一台放IDE,还要预览的情况下。 比如这个样子：或者这个样子:","categories":[{"name":"工具","slug":"工具","permalink":"http://yohnz.github.io/categories/工具/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://yohnz.github.io/tags/sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yohnz.github.io/categories/工具/"}]},{"title":"React自学笔记","slug":"React自学笔记","date":"2016-02-19T10:06:33.000Z","updated":"2016-09-09T09:47:59.531Z","comments":true,"path":"2016/02/19/React自学笔记/","link":"","permalink":"http://yohnz.github.io/2016/02/19/React自学笔记/","excerpt":"本文记录一些我在自学React过程中遇到的问题 getInitialState React在ES6中去掉了getInitialState函数，需要写在constructor中 The API (via ‘extends React.Component’) is similar to React.createClass with the exception of getInitialState. Instead of providing a separate getInitialState method, you set up your own state property in the constructor. 非ES6写法： 12345678var CommentBox = React.createClass(&#123; getInitialState:function()&#123; return &#123;data:[]&#125;; &#125;, return:function()&#123; ...... &#125;&#125;)","text":"本文记录一些我在自学React过程中遇到的问题 getInitialState React在ES6中去掉了getInitialState函数，需要写在constructor中 The API (via ‘extends React.Component’) is similar to React.createClass with the exception of getInitialState. Instead of providing a separate getInitialState method, you set up your own state property in the constructor. 非ES6写法： 12345678var CommentBox = React.createClass(&#123; getInitialState:function()&#123; return &#123;data:[]&#125;; &#125;, return:function()&#123; ...... &#125;&#125;) ES6写法：123456789class CommentBox extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;data:[]&#125; &#125; return()&#123; ...... &#125;&#125; No Autobinding Methods follow the same semantics as regular ES6 classes, meaning that they don’t automatically bind this to the instance. You’ll have to explicitly use .bind(this) or arrow functions =&gt;. ES6中this需要手动绑定：123456789101112131415161718192021222324252627class CommentForm extends React.Component&#123; constructor(props)&#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(e)&#123; e.preventDefault(); var author = this.refs.author.value.trim(); var text = this.refs.text.value.trim(); if(!author || !text)&#123; return; &#125; this.props.onCommentSubmit(&#123;author:author,text:text&#125;); this.refs.author.value = \"\" this.refs.text.value = \"\" return; &#125; render()&#123; return ( &lt;form className=\"commentForm\" onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" placeholder=\"your name\" ref=\"author\"/&gt; &lt;input type=\"text\" placeholder=\"say something...\" ref=\"text\" /&gt; &lt;input type=\"submit\" value=\"Post\" /&gt; &lt;/form&gt; ) &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yohnz.github.io/tags/React/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}]},{"title":"hexo NEXT主题打开慢的问题","slug":"hexo打开慢的问题","date":"2016-02-17T11:07:24.000Z","updated":"2016-08-29T07:19:20.357Z","comments":true,"path":"2016/02/17/hexo打开慢的问题/","link":"","permalink":"http://yohnz.github.io/2016/02/17/hexo打开慢的问题/","excerpt":"今天把博客部署到coding.net上，想加快国内访问速度，部署之后发现依然很慢，F12了一下，发现了这货：原来引用了google字体库，21秒。。。卡的就是你啊。。","text":"今天把博客部署到coding.net上，想加快国内访问速度，部署之后发现依然很慢，F12了一下，发现了这货：原来引用了google字体库，21秒。。。卡的就是你啊。。于是全局搜索fonts.googleapis.com，找到如下引用代码： 123&#123;% if theme.use_font_lato %&#125; &lt;link href=\"//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&amp;subset=latin,latin-ext\" rel=\"stylesheet\" type=\"text/css\"&gt;&#123;% endif %&#125; 这里我们把google节点改成国内的CDN，即把fonts.googleapis.com修改成fonts.useso.com123&#123;% if theme.use_font_lato %&#125; &lt;link href=\"//fonts.useso.com/css?family=Lato:300,400,700,400italic&amp;subset=latin,latin-ext\" rel=\"stylesheet\" type=\"text/css\"&gt;&#123;% endif %&#125; 更新完之后，再打开博客，爽的飞起有木有：","categories":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yohnz.github.io/tags/Hexo/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}]},{"title":"react+webpack+es6基础配置","slug":"react-webpack基础配置","date":"2016-02-17T08:00:20.000Z","updated":"2016-08-29T07:18:57.981Z","comments":true,"path":"2016/02/17/react-webpack基础配置/","link":"","permalink":"http://yohnz.github.io/2016/02/17/react-webpack基础配置/","excerpt":"今天折腾react,发现很多react+webpack的入门文章推荐里的webpack.config.js配置基本如下：1234567891011121314151617module.exports = &#123; entry: \"./entry.js\", output: &#123; path: __dirname + '/dist', filename: \"bundle.js\" &#125;, resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;, module: &#123; loaders: [&#123; test: /\\.js|jsx$/, loader:'babel', exclude: /node_modules/, &#125;] &#125;&#125; 兴致勃勃地写了个hello world,结果webpack编译时一直报错: 123456789101112ERROR in ./entry.jsModule build failed: SyntaxError: E:/myCode/React/entry.js: Unexpected token (4:7) 2 | import &#123;render&#125; from 'react-dom'; 3 | import Hello from './components/Hello'; 4 | render(&lt;Hello name=\"yunl\" /&gt;,document.getElementById(\"test\")); | ^ 5 | 6 | at Parser.pp.raise (E:\\myCode\\React\\node_modules\\babel-core\\node_modules\\babylon\\index.js:1425:13) at Parser.pp.unexpected (E:\\myCode\\React\\node_modules\\babel-core\\node_modules\\babylon\\index.js:2905:8) at Parser.pp.parseExprAtom (E:\\myCode\\React\\node_modules\\babel-core\\node_modules\\babylon\\index.js:754:12) at Parser.pp.parseExprSubscripts (E:\\myCode\\React\\node_modules\\babel-core\\node_modules\\babylon\\index.js:509:19) 逛了很多社区，发现给出的方案都不能解决问题，心里有成千上万的马奔腾而过啊！最后折腾了很久发现，需要在webpack.config.js里添加：","text":"今天折腾react,发现很多react+webpack的入门文章推荐里的webpack.config.js配置基本如下：1234567891011121314151617module.exports = &#123; entry: \"./entry.js\", output: &#123; path: __dirname + '/dist', filename: \"bundle.js\" &#125;, resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;, module: &#123; loaders: [&#123; test: /\\.js|jsx$/, loader:'babel', exclude: /node_modules/, &#125;] &#125;&#125; 兴致勃勃地写了个hello world,结果webpack编译时一直报错: 123456789101112ERROR in ./entry.jsModule build failed: SyntaxError: E:/myCode/React/entry.js: Unexpected token (4:7) 2 | import &#123;render&#125; from 'react-dom'; 3 | import Hello from './components/Hello'; 4 | render(&lt;Hello name=\"yunl\" /&gt;,document.getElementById(\"test\")); | ^ 5 | 6 | at Parser.pp.raise (E:\\myCode\\React\\node_modules\\babel-core\\node_modules\\babylon\\index.js:1425:13) at Parser.pp.unexpected (E:\\myCode\\React\\node_modules\\babel-core\\node_modules\\babylon\\index.js:2905:8) at Parser.pp.parseExprAtom (E:\\myCode\\React\\node_modules\\babel-core\\node_modules\\babylon\\index.js:754:12) at Parser.pp.parseExprSubscripts (E:\\myCode\\React\\node_modules\\babel-core\\node_modules\\babylon\\index.js:509:19) 逛了很多社区，发现给出的方案都不能解决问题，心里有成千上万的马奔腾而过啊！最后折腾了很久发现，需要在webpack.config.js里添加：query: {presets: [&#39;react&#39;, &#39;es2015&#39;]} ==！然后，分别install 一下：123npm install babel-preset-react --save-dev mpm install babel-preset-es2015 --save-dev 最终的webpack.config.js配置如下：1234567891011121314151617181920module.exports = &#123; entry: \"./entry.js\", output: &#123; path: __dirname + '/dist', filename: \"bundle.js\" &#125;, resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;, module: &#123; loaders: [&#123; test: /\\.js|jsx$/, loader:'babel', exclude: /node_modules/, query: &#123; presets: ['react', 'es2015'] &#125; &#125;] &#125;&#125; 最有还要注意一点的是 React 0.14版本后的React拆分成了react和react-dom 。 其中 react package 中包含 React.createElement、.createClass、.Component，.PropTypes，.Children这些API，而react-dom package中包含ReactDOM.render、.unmountComponentAtNode、.findDOMNode。 所以之前的React.render要改成ReactDOM.render:1234import React from 'react';import ReactDOM from 'react-dom';import Hello from './components/Hello';ReactDOM.render(&lt;Hello name=\"yunl\" /&gt;,document.getElementById(\"test\")); 希望此文能帮助初学者少踩两个坑!","categories":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yohnz.github.io/tags/React/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yohnz.github.io/categories/前端/"}]}]}